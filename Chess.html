<html>
<body>
<canvas id="chessboard" onclick = "mouseStop()" width="675" height="675" style="border:3px solid #d3d3d3;" >
</canvas>

<script type="text/javascript">

//WIP Features: Player turn rules (eating your own peices, moving other player's peices, etc.), Collision detection bewtween pieces, Pawns changing into other pieces, Special rules (castling, en passant, etc.)

//Functions and varibles for clicking on the chessboard.
{
//Every time the canvas is pressed, the x and y coordinates of the mouse are logged in nextTurnOrigin the first time and nextTurnDestination.
//At the beginning of the next turn, mouseStopVar should be reset to 0.

//Offset for the canvas from the edge of the screen. I should change this.
var xOffset = 10;
var yOffset = 10;

var nextTurnOrigin = [0,0];
var nextTurnDestination = [0,0];

function getMouseCoordsOrigin(event) {
	nextTurnOrigin[0] = event.clientX - xOffset;
	nextTurnOrigin[1] = event.clientY - yOffset;
};

function getMouseCoordsDestination(event) {
	nextTurnDestination[0] = event.clientX - xOffset;
	nextTurnDestination[1] = event.clientY - yOffset;
};

var mouseStopVar = 0; 

//This function calls gameLoop after two clicks are registered and the coords have been recorded, then it resets mouseStopVar.
function mouseStop (){
	if (mouseStopVar == 0) {
		getMouseCoordsOrigin(event);
		if (mouseToArray(nextTurnOrigin) == empty) {
			alert ("There is no piece there.")
		} else if (turnChoose() == true) {
			drawBlueOutline(nextTurnOrigin[0], nextTurnOrigin[1]);
			mouseStopVar = mouseStopVar + 1;
		} else {
			alert ("It is not your turn.");
		};
	} else {
		getMouseCoordsDestination(event);
		gameLoop();
		mouseStopVar = 0;
	};
};

}; 

//Chessboard Outline Drawing Functions:
{
function drawChessboardOutline () {
	var c = document.getElementById("chessboard");
	var ctx = c.getContext("2d");
    var background = new Image();
    background.src = "background.png";
    background.onload = function() {
     ctx.drawImage(background,0,0,675,675);
    };
	
	var HTMLchessboard = document.getElementById("chessboard");
	var ctx = HTMLchessboard.getContext("2d");
	ctx.lineWidth = 4;	
	
	ctx.moveTo(0,0);
	ctx.lineTo(0,0);
	ctx.stroke();
	
	ctx.moveTo(0,75);
	ctx.lineTo(675,75);
	ctx.stroke();
	
	ctx.moveTo(0,150);
	ctx.lineTo(675,150);
	ctx.stroke();
	
	ctx.moveTo(0,225);
	ctx.lineTo(675,225);
	ctx.stroke();
	
	ctx.moveTo(0,300);
	ctx.lineTo(675,300);
	ctx.stroke();
	
	ctx.moveTo(0,375);
	ctx.lineTo(675,375);
	ctx.stroke();
	
	ctx.moveTo(0,450);
	ctx.lineTo(675,450);
	ctx.stroke();
	
	ctx.moveTo(0,525);
	ctx.lineTo(675,525);
	ctx.stroke();
	
	ctx.moveTo(0,600);
	ctx.lineTo(675,600);
	ctx.stroke();
	
	ctx.moveTo(0,675);
	ctx.lineTo(675,675);
	ctx.stroke();
	
};


function drawBlueOutline (x,y) { 
	var xNew = x;
	var yNew = y;
	
	while (xNew % 75 != 0) {
		xNew = xNew - 1;
	};
	
	while (yNew % 75 != 0) {
		yNew = yNew - 1;
	};

	var c = document.getElementById("chessboard");
	var ctx = c.getContext("2d");
    var blue_outline = new Image();
    blue_outline.src = "blue_outline.png";
    blue_outline.onload = function() {
     ctx.drawImage(blue_outline,xNew,yNew,75,75);
	};
};

};
			
//Chessboard Arrays and Chessboard Drawing / Piece Placing Function:
{

//NOTE THAT NAMING OF THE ARRAYS IS BACKWARDS FROM ACTUAL DISPLAY LABELS ON THE CANVAS 
//(i.e. chessBoard1 is actually labeled "8", chessBoard5 is actually labeled "4", chessBoard8 is actually labeled "1", etc...)

var empty = "***";

var ro = "ro";
var kn = "kn";
var bi = "bi";
var qu = "qu";
var ki = "ki";
var pa = "pa";

var RO = "RO";
var KN = "KN";
var BI = "BI";
var QU = "QU";
var KI = "KI";
var PA = "PA";

var chessBoard1 = [ro,kn,bi,qu,ki,bi,kn,ro];
var chessBoard2 = [pa,pa,pa,pa,pa,pa,pa,pa];
var chessBoard3 = [empty,empty,empty,empty,empty,empty,empty,empty];
var chessBoard4 = [empty,empty,empty,empty,empty,empty,empty,empty];
var chessBoard5 = [empty,empty,empty,empty,empty,empty,empty,empty];
var chessBoard6 = [empty,empty,empty,empty,empty,empty,empty,empty];
var chessBoard7 = [PA,PA,PA,PA,PA,PA,PA,PA];	
var chessBoard8 = [RO,KN,BI,QU,KI,BI,KN,RO];

//This function places a piece on 'HTMLchessboard' 
//Input: Chess Piece Variable, X-Coord on Canvas, Y-Coord on Canvas
//Output: none (only draws the pieces using .png images (inlcuded in folder) on the html canvas, 'HTMLchessboard')
//NOTE: Only called through "drawChessboard" becuase only it has the appropriate x and y coordinates for the canvas.
function placePiece (piece, x, y) {
	switch(piece) {
		case "RO":
			var c = document.getElementById("chessboard");
			var ctx = c.getContext("2d");
			var whiteRook = new Image();
			whiteRook.src = "whiteRook.png";
			whiteRook.onload = function() {
				ctx.drawImage(whiteRook,x,y,75,75);
			};	
			break;
		case "KN":
			var c = document.getElementById("chessboard");
			var ctx = c.getContext("2d");
			var whiteKnight = new Image();
			whiteKnight.src = "whiteKnight.png";
			whiteKnight.onload = function() {
				ctx.drawImage(whiteKnight,x,y,75,75);
			};	
			break;
		case "BI":
			var c = document.getElementById("chessboard");
			var ctx = c.getContext("2d");
			var whiteBishop = new Image();
			whiteBishop.src = "whiteBishop.png";
			whiteBishop.onload = function() {
				ctx.drawImage(whiteBishop,x,y,75,75);
			};	
			break;
		case "QU":
			var c = document.getElementById("chessboard");
			var ctx = c.getContext("2d");
			var whiteQueen = new Image();
			whiteQueen.src = "whiteQueen.png";
			whiteQueen.onload = function() {
				ctx.drawImage(whiteQueen,x,y,75,75);
			};	
			break;
		case "KI":
			var c = document.getElementById("chessboard");
			var ctx = c.getContext("2d");
			var whiteKing = new Image();
			whiteKing.src = "whiteKing.png";
			whiteKing.onload = function() {
				ctx.drawImage(whiteKing,x,y,75,75);
			};	
			break;
		case "PA":
			var c = document.getElementById("chessboard");
			var ctx = c.getContext("2d");
			var whitePawn = new Image();
			whitePawn.src = "whitePawn.png";
			whitePawn.onload = function() {
				ctx.drawImage(whitePawn,x,y,75,75);
			};	
			break;
		case "ro":
			var c = document.getElementById("chessboard");
			var ctx = c.getContext("2d");
			var blackRook = new Image();
			blackRook.src = "blackRook.png";
			blackRook.onload = function() {
				ctx.drawImage(blackRook,x,y,75,75);
			};	
			break;
		case "kn":
			var c = document.getElementById("chessboard");
			var ctx = c.getContext("2d");
			var blackKnight = new Image();
			blackKnight.src = "blackKnight.png";
			blackKnight.onload = function() {
				ctx.drawImage(blackKnight,x,y,75,75);
			};	
			break;
		case "bi":
			var c = document.getElementById("chessboard");
			var ctx = c.getContext("2d");
			var blackBishop = new Image();
			blackBishop.src = "blackBishop.png";
			blackBishop.onload = function() {
				ctx.drawImage(blackBishop,x,y,75,75);
			};	
			break;
		case "qu":
			var c = document.getElementById("chessboard");
			var ctx = c.getContext("2d");
			var blackQueen = new Image();
			blackQueen.src = "blackQueen.png";
			blackQueen.onload = function() {
				ctx.drawImage(blackQueen,x,y,75,75);
			};	
			break;
		case "ki":
			var c = document.getElementById("chessboard");
			var ctx = c.getContext("2d");
			var blackKing = new Image();
			blackKing.src = "blackKing.png";
			blackKing.onload = function() {
				ctx.drawImage(blackKing,x,y,75,75);
			};	
			break;
		case "pa":
			var c = document.getElementById("chessboard");
			var ctx = c.getContext("2d");
			var blackPawn = new Image();
			blackPawn.src = "blackPawn.png";
			blackPawn.onload = function() {
				ctx.drawImage(blackPawn,x,y,75,75);
			};
			break;
	};		
};	

//This function places uses the Chessboard Arrays above to place a peice on 'HTMLchessboard'
//This function should be run after every "movePiece" or every turn so changes are reflected on the canvas, 'HTMLchessboard'
//Relies On: "placePiece"
function drawChessboard () {
	var i = 0;
    while (i < 8) {
		placePiece(chessBoard1[i],((75 * i) + 75), 0);
        i++;
    };
	var i = 0;
    while (i < 8) {
		placePiece(chessBoard2[i],((75 * i) + 75), 75);
        i++;
    };	
	var i = 0;
    while (i < 8) {
		placePiece(chessBoard3[i],((75 * i) + 75), 150);
        i++;
    };
	var i = 0;
    while (i < 8) {
		placePiece(chessBoard4[i],((75 * i) + 75), 225);
        i++;
    };	
	var i = 0;
    while (i < 8) {
		placePiece(chessBoard5[i],((75 * i) + 75), 300);
        i++;
    };
	var i = 0;
    while (i < 8) {
		placePiece(chessBoard6[i],((75 * i) + 75), 375);
        i++;
    };	
	var i = 0;
    while (i < 8) {
		placePiece(chessBoard7[i],((75 * i) + 75), 450);
        i++;
    };
	var i = 0;
    while (i < 8) {
		placePiece(chessBoard8[i],((75 * i) + 75), 525);
        i++;
    };		
};
};

//Mouse Coords <--> Chessboard Array Coords <--> Chess Piece Variable FUNCTIONS:
{

//This function returns the peice on the chessboard.
//Input: Mouse Coords in the Array [x,y] 
//Output: Chess Piece Variable
function mouseToArray (mouseCoords) {
	var x = mouseCoords[0];
	var y = mouseCoords[1];
	var column = 0;
	if ((x > 75) && (x < 150)) {
		column = 0;
	} else if ((x > 150) && (x <= 225)) {
		column = 1;
	} else if ((x > 225) && (x <= 300)) {
		column = 2; 
	} else if ((x > 300) && (x <= 375)) {
		column = 3;
	} else if ((x > 375) && (x <= 450)) {
		column = 4;
	} else if ((x > 450) && (x <= 525)) {
		column = 5;
	} else if ((x > 525) && (x <= 600)) {
		column = 6;
	} else if ((x > 600) && (x <= 675)) {
		column = 7;
	} else {
		column = 0;
	};
	
	if ((y > 0) && (y < 75)) {
		return chessBoard1[column]; 
	} else if ((y > 75) && (y <= 150)) {
		return chessBoard2[column]; 
	} else if ((y > 150) && (y <= 225)) {
		return chessBoard3[column]; 
	} else if ((y > 225) && (y <= 300)) {
		return chessBoard4[column]; 
	} else if ((y > 300) && (y <= 375)) {
		return chessBoard5[column]; 
	} else if ((y > 375) && (y <= 450)) {
		return chessBoard6[column]; 
	} else if ((y > 450) && (y <= 525)) {
		return chessBoard7[column]; 
	} else if ((y > 525) && (y <= 600)) {
		return chessBoard8[column]; 
	} else {
		return chessBoard1[column]; 
	};
	
};

//This function returns the coords as an array [x,y] on the chessbord, but y-axis labeling is flipped from the labels on the drawn board. 
//Input: Mouse Coords in the Array [x,y]
//Output: Chessboard Array Coords
function mouseToCoords (mouseCoords) {
	var x = mouseCoords[0];
	var y = mouseCoords[1];	
	var coords = ['x','y'];
	var column = 0;
	var row = 0;
	if ((x > 75) && (x < 150)) {
		column = "1";
	} else if ((x > 150) && (x <= 225)) {
		column = "2";
	} else if ((x > 225) && (x <= 300)) {
		column = "3"; 
	} else if ((x > 300) && (x <= 375)) {
		column = "4";
	} else if ((x > 375) && (x <= 450)) {
		column = "5";
	} else if ((x > 450) && (x <= 525)) {
		column = "6";
	} else if ((x > 525) && (x <= 600)) {
		column = "7";
	} else if ((x > 600) && (x <= 675)) {
		column = "8";
	} else {
		column = "1";
	};
	
	if ((y > 0) && (y < 75)) {
		row = ("1"); 
	} else if ((y > 75) && (y <= 150)) {
		row = ("2"); 
	} else if ((y > 150) && (y <= 225)) {
		row = ("3"); 
	} else if ((y > 225) && (y <= 300)) {
		row = ("4"); 
	} else if ((y > 300) && (y <= 375)) {
		row = ("5"); 
	} else if ((y > 375) && (y <= 450)) {
		row = ("6"); 
	} else if ((y > 450) && (y <= 525)) {
		row = ("7"); 
	} else if ((y > 525) && (y <= 600)) {
		row = ("8"); 
	} else {
		row = ("1"); 
	};
	coords = [column, row];
	return coords;
};

//This function takes the coords as an array [x,y] and returns the peice.
//Input: Chessboard Array Coords
//Output: Chess Piece Variable
function coordsToArray (coords) {
	var column = (coords[0] - 1);
	var finalLocation = 0;
	switch(coords[1]) {
		case "1":
			finalLocation = chessBoard1[column];
			break;
		case "2":
			finalLocation = chessBoard2[column];
			break;
		case "3":
			finalLocation = chessBoard3[column];
			break;
		case "4":
			finalLocation = chessBoard4[column];
			break;
		case "5":
			finalLocation = chessBoard5[column];
			break;
		case "6":
			finalLocation = chessBoard6[column];
			break;
		case "7":
			finalLocation = chessBoard7[column];
			break;
		case "8":
			finalLocation = chessBoard8[column];
			break;
	};
	return finalLocation;
};

//This function takes the coords as an array [x,y] and returns the upper left coordinate of the square for the canvas.
//Input: Chessboard Array Coords
//Output: Canvas Coords as an array [x,y]
function coordsToCanvas (coords) {
	var canvasCoords = ['x','y'];
	canvasCoords[0] = coords[0] * 75;
	canvasCoords[1] = (coords[1] * 75) - 75;
};
};

//Piece Check Functions:
//These checks use algorithmns determin whether or not a chess move is valid.
//These functions are called through the moveCheck function only.
{
function kingCheck (origin, destination){
	if ((Math.abs(origin[0] - destination[0]) <= 1) && (Math.abs(origin[1] - destination[1]) <= 1)) {
		console.log("kingCheck has returned true.");
		return true;
	} else {
		return false;
	};
};

function queenCheck (origin, destination) {
	if ((origin[0] == destination[0]) || (origin[1] == destination[1])) {
		console.log("queenCheck has returned true.");
		return true;
	} else if (Math.abs(origin[0] - destination[0]) == Math.abs(origin[1] - destination[1])) {
		console.log("queenCheck has returned true.");
		return true;
	} else {
		return false;
	};
};

function rookCheck (origin, destination) {
	if ((origin[0] == destination[0]) || (origin[1] == destination[1])) {
		console.log("rookCheck has returned true.");
		return true;
	} else {
		return false;
	};
};

function bishopCheck (origin, destination) {
	if (Math.abs(origin[0] - destination[0]) == Math.abs(origin[1] - destination[1])) {
		console.log("bishopCheck has returned true.");
		return true;
	} else {
		return false;
	};
};

function knightCheck (origin, destination) {
	if ((Math.abs(origin[0] - destination[0]) == 2) && (Math.abs(origin[1] - destination[1]) == 1)) {
		console.log("bishopCheck has returned true.");
		return true;
	} else if ((Math.abs(origin[1] - destination[1]) == 2) && (Math.abs(origin[0] - destination[0]) == 1)) {
		console.log("bishopCheck has returned true.");
		return true;
	} else {
		return false;
	};
};

function whitePawnCheck (origin, destination) {
	if ((Math.abs(destination[0] - origin[0]) == 1) && (coordsToArray(destination) != empty) && (origin[1] - destination[1] == 1)) {
		console.log("whitePawnCheck has returned true.");
		return true;
	} else if (coordsToArray(destination) != empty) {
		return false;
	} else if ((origin[0] == destination[0]) && (origin[1] - destination[1] == 1)){
		console.log("whitePawnCheck has returned true.");
		return true;	
	} else if ((origin[0] == destination[0]) && (origin[1] - destination[1] == 2) && (origin[1] == 7)) {
		console.log("whitePawnCheck has returned true.");
		return true;
	} else {
		return false;
	};
};

function blackPawnCheck (origin, destination) {
	if ((Math.abs(destination[0] - origin[0]) == 1) && (coordsToArray(destination) != empty) && (destination[1] - origin[1] == 1)) {
		console.log("blackPawnCheck has returned true.");
		return true; 
	} else if (coordsToArray(destination) != empty) {
		return false;
	} else if ((origin[0] == destination[0]) && (destination[1] - origin[1] == 1)){
		console.log("blackPawnCheck has returned true.");
		return true;
	} else if ((origin[0] == destination[0]) && (destination[1] - origin[1] == 2) && (origin[1] == 2)) {
		console.log("blackPawnCheck has returned true.");
		return true;
	} else {
		return false;
	};
};
};

//Special Gamerules Functions:
//These are to be tested for before normal movement checks in "gameLoop".
//Includes "whiteCastling", "blackCastling"
{

var whiteCastleYet = false; 
var blackCastleYet = false;

//This function checks if white is trying to castle queenside or kingside and checks the validity as well as moves the pieces.
//Input: none (run through gameLoop())
//Output: Boolean and calls on movePiece
//Relies On: "mouseToCoords", "mouseToArray", "nextTurnDestination", "nextTurnOrigin","movePiece", and the chessBoard arrays
function whiteCastling() {
	var destinationCoords = mouseToCoords(nextTurnDestination);
	if (mouseToArray(nextTurnOrigin) == KI && destinationCoords[0] == 7 && whiteCastleYet == false
	&& destinationCoords[1] == 8 && chessBoard8[7] == RO && chessBoard8[6] == empty && chessBoard8[5] == empty) {
		movePiece(mouseToCoords(nextTurnOrigin),mouseToCoords(nextTurnDestination));
		movePiece(['8','8'],['6','8']);
		console.log ("White has kingside castled.");
		return true;
	} else if (mouseToArray(nextTurnOrigin) == KI && destinationCoords[0] == 2 && blackCastleYet == false
	&& destinationCoords[1] == 8 && chessBoard8[0] == RO && chessBoard8[1] == empty && chessBoard8[2] == empty && chessBoard8[3] == empty) {
		movePiece(mouseToCoords(nextTurnOrigin),mouseToCoords(nextTurnDestination));
		movePiece(['1','8'],['3','8']);
		console.log ("White has queenside castled.");
		return true;
	} else {
		return false;
	};
};

//This function checks if black is trying to castle queenside or kingside and checks the validity as well as moves the pieces.
//Input: none (run through gameLoop())
//Output: Boolean and calls on movePiece
//Relies On: "mouseToCoords", "mouseToArray", "nextTurnDestination", "nextTurnOrigin","movePiece", and the chessBoard arrays
function blackCastling() {
	var destinationCoords = mouseToCoords(nextTurnDestination);
	if (mouseToArray(nextTurnOrigin) == ki && destinationCoords[0] == 7 
	&& destinationCoords[1] == 1 && chessBoard1[7] == ro && chessBoard1[6] == empty && chessBoard1[5] == empty) {
		movePiece(mouseToCoords(nextTurnOrigin),mouseToCoords(nextTurnDestination));
		movePiece(['8','1'],['6','1']);
		console.log ("White has kingside castled.");
		return true;
	} else if (mouseToArray(nextTurnOrigin) == ki && destinationCoords[0] == 2
	&& destinationCoords[1] == 1 && chessBoard1[0] == ro && chessBoard1[1] == empty && chessBoard1[2] == empty && chessBoard1[3] == empty) {
		movePiece(mouseToCoords(nextTurnOrigin),mouseToCoords(nextTurnDestination));
		movePiece(['1','1'],['3','1']);
		console.log ("White has queenside castled.");
		return true;
	} else {
		return false;
	};
};

};

//This function finds the correct piece check function and runs it.
//Input: Chess Piece Variable
//Output: Boolean based on the Piece Check Functions 
//Relies On: "mouseToCoords", "nextTurnDestination", "nextTurnOrigin"
function moveCheck (piece) {
	if ((piece == KI) || (piece == ki)) {
		return kingCheck(mouseToCoords(nextTurnOrigin), mouseToCoords(nextTurnDestination));
	} else if ((piece == QU) || (piece == qu)) {
		return queenCheck(mouseToCoords(nextTurnOrigin), mouseToCoords(nextTurnDestination));
	} else if ((piece == BI) || (piece == bi)) {
		return bishopCheck(mouseToCoords(nextTurnOrigin), mouseToCoords(nextTurnDestination));
	} else if ((piece == KN) || (piece == kn)) {
		return knightCheck(mouseToCoords(nextTurnOrigin), mouseToCoords(nextTurnDestination));
	} else if ((piece == RO) || (piece == ro)) {
		return rookCheck(mouseToCoords(nextTurnOrigin), mouseToCoords(nextTurnDestination));
	} else if (piece == PA) {
		return whitePawnCheck(mouseToCoords(nextTurnOrigin), mouseToCoords(nextTurnDestination));
	} else if (piece == pa) {
		return blackPawnCheck(mouseToCoords(nextTurnOrigin), mouseToCoords(nextTurnDestination));
	} else if (piece == empty) {
		return "There is no piece located there.";
	} else {
		return "Error: function checkDecider";
	};
};

//This function tells gameLoop() whether or not peices are trying to move to the same place they started on.
//Input: none (uses nextTurnOrigin and nextTurnDestination)
//Output: Boolean
//Relies On: "mouseToCoords", "mouseToArray", "nextTurnOrigin". "nextTurnDestination"
function samePlace() {
	var originCoords = mouseToCoords(nextTurnOrigin);
	var destinationCoords = mouseToCoords(nextTurnDestination);
	if ((originCoords[0] === destinationCoords[0]) && (originCoords[1] === destinationCoords[1])) {
		console.log (mouseToArray(nextTurnOrigin) + " is trying to eat itself.");
		return false;	
	} else {
		return true;
	};
};

//Moves peices as using array coords of origin and destination. 
//Input: Chessboard Array Coords
//Output: none (changes location of pieces in the chessboard arrays)
//Relies On: "coordsToArray"
function movePiece (origin, destination) {
	var originPiece = coordsToArray(origin);
	var destinationColumn
	var destinationColumn = destination[0] - 1;
	switch(destination[1]) { //replaces the eaten piece with a blank square
		case "1":
			chessBoard1[destinationColumn] = empty;
			break;
		case "2":
			chessBoard2[destinationColumn] = empty;
			break;
		case "3":
			chessBoard3[destinationColumn] = empty;
			break;
		case "4":
			chessBoard4[destinationColumn] = empty;
			break;
		case "5":
			chessBoard5[destinationColumn] = empty;
			break;
		case "6":
			chessBoard6[destinationColumn] = empty;
			break;
		case "7":
			chessBoard7[destinationColumn] = empty;
			break;
		case "8":
			chessBoard8[destinationColumn] = empty;
			break;
	};
	
	drawChessboardOutline();
	drawChessboard();
	
	switch(destination[1]) { //puts the chess piece in the destination 
		case "1":
			chessBoard1[destinationColumn] = originPiece;
			break;
		case "2":
			chessBoard2[destinationColumn] = originPiece;
			break;
		case "3":
			chessBoard3[destinationColumn] = originPiece;
			break;
		case "4":
			chessBoard4[destinationColumn] = originPiece;
			break;
		case "5":
			chessBoard5[destinationColumn] = originPiece;
			break;
		case "6":
			chessBoard6[destinationColumn] = originPiece;
			break;
		case "7":
			chessBoard7[destinationColumn] = originPiece;
			break;
		case "8":
			chessBoard8[destinationColumn] = originPiece;
			break;
	};
	var originColumn = origin[0] - 1;
	switch(origin[1]) { //makes the origin blank
		case "1":
			chessBoard1[originColumn] = empty;
			break;
		case "2":
			chessBoard2[originColumn] = empty;
			break;
		case "3":
			chessBoard3[originColumn] = empty;
			break;
		case "4":
			chessBoard4[originColumn] = empty;
			break;
		case "5":
			chessBoard5[originColumn] = empty;
			break;
		case "6":
			chessBoard6[originColumn] = empty;
			break;
		case "7":
			chessBoard7[originColumn] = empty;
			break;
		case "8":
			chessBoard8[originColumn] = empty;
			break;
	};
};
 
 
//START CALLING FUNCTIONS AND DOING GAMEFLOW STUFF 

//Drawing the outline of the HTML chessboard on the canvas, 'HTMLchessboard'
drawChessboardOutline();
//Waiting three seconds until after the board outline is drawn the placing the starting pieces on it.
setTimeout(drawChessboard(), 5000);
 
 
//Gameflow Variables and Loops:
{

var playerTurn = 1;

//This function determines whether or not it is your turn.
function turnChoose() {
	if ((playerTurn == 1) && (mouseToArray(nextTurnOrigin) == KI || mouseToArray(nextTurnOrigin) == QU || mouseToArray(nextTurnOrigin) == BI || mouseToArray(nextTurnOrigin) == KN || mouseToArray(nextTurnOrigin) == RO || mouseToArray(nextTurnOrigin) == PA)) {
		return true;
	} else if ((playerTurn == -1) && (mouseToArray(nextTurnOrigin) == ki || mouseToArray(nextTurnOrigin) == qu || mouseToArray(nextTurnOrigin) == bi || mouseToArray(nextTurnOrigin) == kn || mouseToArray(nextTurnOrigin) == ro || mouseToArray(nextTurnOrigin) == pa)){
		return true;
	} else {
		return false;
	};
};

//This function determines whether or not you can eat a particular piece.
function eatPiece() {
	if ((playerTurn == -1) && (mouseToArray(nextTurnDestination) == KI || mouseToArray(nextTurnDestination) == QU || mouseToArray(nextTurnDestination) == BI || mouseToArray(nextTurnDestination) == KN || mouseToArray(nextTurnDestination) == RO || mouseToArray(nextTurnDestination) == PA || mouseToArray(nextTurnDestination) == empty)) {
		return true;
	} else if ((playerTurn == 1) && (mouseToArray(nextTurnDestination) == ki || mouseToArray(nextTurnDestination) == qu || mouseToArray(nextTurnDestination) == bi || mouseToArray(nextTurnDestination) == kn || mouseToArray(nextTurnDestination) == ro || mouseToArray(nextTurnDestination) == pa || mouseToArray(nextTurnDestination) == empty)){
		return true;
	} else {
		return false;
	};	
};

//This function is called when mouseStop is called for the second time and moves pieces.
function gameLoop () {
	if ((mouseToArray(nextTurnDestination)) == KI && moveCheck(mouseToArray(nextTurnOrigin)) == true && gameFlow() == true) {
		movePiece(mouseToCoords(nextTurnOrigin), mouseToCoords(nextTurnDestination));	
		alert ("Black has won!");		
		drawChessboardOutline();
		drawChessboard();
		
	} else if ((mouseToArray(nextTurnDestination)) == ki && moveCheck(mouseToArray(nextTurnOrigin)) == true && gameFlow() == true) {
		movePiece(mouseToCoords(nextTurnOrigin), mouseToCoords(nextTurnDestination));	
		alert ("White has won!");		
		drawChessboardOutline();
		drawChessboard();
		
	} else if (mouseToArray(nextTurnOrigin) == empty) {
		alert ("There is no piece there.");
		drawChessboardOutline();
		drawChessboard();
		
	} else if (whiteCastling() == true && whiteCastleYet == false && turnChoose() == true) { 
		whiteCastleYet = true;
		playerTurn = playerTurn * (-1);
		drawChessboardOutline();
		drawChessboard();
				
	} else if (blackCastling() == true && blackCastleYet == false && turnChoose() == true) { 
		blackCastleYet = true;
		playerTurn = playerTurn * (-1);
		drawChessboardOutline();
		drawChessboard();
		
	} else if (moveCheck(mouseToArray(nextTurnOrigin)) == true && samePlace() == true && turnChoose() == true && eatPiece() == true) {
		originBeforeMovement = mouseToArray(nextTurnOrigin); //Only used for console.log
		movePiece(mouseToCoords(nextTurnOrigin), mouseToCoords(nextTurnDestination));
		playerTurn = playerTurn * (-1);
		drawChessboardOutline();
		drawChessboard();
		
		//For console log.
		console.log(originBeforeMovement + " moved to " + mouseToCoords(nextTurnDestination));
		console.log(chessBoard1);
		console.log(chessBoard2);
		console.log(chessBoard3);
		console.log(chessBoard4);
		console.log(chessBoard5);
		console.log(chessBoard6);
		console.log(chessBoard7);
		console.log(chessBoard8);
		//For console log.

	} else if (eatPiece() == false) {
		alert ("You cannot eat your own pieces.");
		drawChessboardOutline();
		drawChessboard();
		
	} else {
		alert ("That is not a valid move. Please try again.");
		drawChessboardOutline();
		drawChessboard();
	};
};	
};


</script>
</body>
</html>
